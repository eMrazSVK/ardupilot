Po clone git repo lokalne, treba spustiť ešte:

cd ardupilot
git submodule update --init --recursive

build FW pre Pixhawk (copter):

	cd ardupilot/ArduCopter
	make px4-v2

upload do Pixhawk:

	a)cez Mission Planner
	b) make px4-v2-upload -> toto, keď je nahraný zlý FW a Mission Planner ho	 		nerozozná

Spúšťanie príkladov z http://ardupilot.org/dev/docs/learning-ardupilot-the-example-sketches.html
	
	najprv: ./waf configure 
			./waf configure --board=px4-v2 (pre pixhawk)

	cd ardupilot
	./waf build --target examples/<nazov príkladu> --upload
	

Otestovanie príkladu (pre výpis zo sériových portov) - musí byť pripojený serial priamo do USB, nefunguje Pixhawk USB Port

	mavproxy.py --setup --master /dev/ttyUSB0 
	alebo
	sudo putty /dev/ttyUSB0 -serial -sercfg 57600,8,n,1,N

Vlastne funkcie:

	1. *.cpp subor do ardupilot/ArduCopter -> v ňom #include "Copter.h"
	2. treba deklarovať funkcie ako napr. void Copter::<meno_funkcie>()
	3. Zadeklarovat funkcie v Copter.h subore
	4. Pridať do taskScheduleru v Copter.cpp
	
Poslanie správy gcs pomocou MAVLink: 
	gcs().send_text(MAV_SEVERITY_WARNING,str);
	                    ^ toto je identifikátor závažnosti správy

Posielanie cez UART-> Netreba (zatiaľ) nič konfigurovať, stačí iba vo vlastnom
.cpp súbore zavolať (občas to vypíše neznáme znaky? Niekedy aj nie): 
	hal.uartD->printf(" ");
	
Treba naštudovať timer-y, ako do nich zaradiť napr. výpis do UART.

==============Začiatok implementácie protokolu====================

Posielanie údajov do motorov s frekvenciou 400 Hz !! 
    V ArduCopter.cpp je to v slučke fast_loop()
    
Bude potrebné doimplemetovať protokol tak, aby sa mohol voliť napríklad v mission planner.

Treba použiť na zapisovanie/čítanie serial portu knižnicu (asi) AP_SerialManager. (HAL vie posielať iba uint8_t)

Nemôže byť include A.h v B.h a súčasne B.h v A.h (linker sa zacyklí) -> radšej include v A.cpp atď.

Pridanie protokolu je možné v :
    - AP_SerialManager.h 
    
Treba si urobiť objekty (takto napr.):
    - AP_HAL::UARTDriver *_port; -> pre obsluhu serial, posielanie
    - AP_SerialManager::SerialProtocol _protocol; -> pre správu protokolu 
    
Unsigned/signed problém -> všetky údaje so znamienkom (signed) stačí bitovo zapísať do unsigned a poslať ich. Po prijatí sa opäť použijú (nie je to moja starosť - zatiaľ) ( link na tento problém na SO: https://stackoverflow.com/questions/30048135/efficient-way-to-bit-copy-a-signed-integer-to-an-unsigned-integer ) EDIT: memcpy vyzerá, že funguje -> memcpy signed do unsigned a naspäť na signed

Plnenie packetu -> v maine (čiže asi ArduCopter.cpp) sa vytvorí objekt ADB_Proto <meno_objektu> a z neho sa volajú funkcie na naplnenie packetu a poslanie. Forma samotných dát je zatiaľ neznáma, čiže ešte sa to nerieši. Zatiaľ je hotový prázdny frame s preddefinovanými bajtmi: START, END, CHECKSUM (vyrátané, funkcia hotová). 

Už treba zakomponovať do celkového projektu posielanie celého frame-u pomocou UART (pomocné pojmy: SerialManager, port->write(), UARTDriver) -> ak bude toto hotové, treba si naštudovať, ako sa celý protokol "vnorí" do autopilota a Mission Planner-a

ADB_Proto::tick sa volá cez zaregistrovanie procesu - niečo ako AP_HAL::Register_io_process(ADB_Proto::tick)... 
Zostáva zistiť, kde sa volá init FrSky -> EDIT: frsky telem init() sa volá v ardupilot->ArduCopter->system.cpp

#IFDEF ADB_PROTO bol vykonany zatial v:
        - config.h
        - bol vytvorený objekt  v Copter.h, konkrétne ADB_Proto adb_light_proto
        - Copter.h #if ADB_PROTO_ENABLED == ENABLED tak include <adb_proto/adb_proto.h>
        - system.cpp pridaný #if ADB_PROTO_ENABLED == ENABLED tak zavolaj adb_light_proto.init()
        - 
        
Neisté dependencies:
    - v Copter.cpp sa volá frsky_telemetry() konštruktor, možno bude treba volať aj adb_proto() konštruktor
    - flight_mode.cpp -> napr. FRSKY tam volá frsky_telemetry.update_control_mode() -> neviem čo to je zatiaľ
    - v make.inc treba asi pridať ADB_Proto ako knižnicu | EDIT: Hotovo
    - v sensors.cpp FRSKY opäť volá frsky_telemetry.update_sensor_status_flags() -> opäť neviem, na čo to slúži
    - AP_Arming.cpp.d neviem čo je to za súbor ale je tam cesta ku všetkým knižniciam | EDIT: Pridaná aj cesta k ADB_Proto.h
    

Trebalo pridať v AP_SerialManager v enum SerialProtocol SerialProtocol_ADB_Proto (náš protokol) + default baud a buff veľkosti

POZOR! Treba zistiť, ako pridať protokol tak, aby sa zobrazil v MISSION Plannery (bude to niekde v serialmanager.cpp alebo .h)

Na komunikacii (seriovy port) treba poriešiť inicializaciu smerniku ADB_Port - zatial je napevno nastavený Serial5

V súbore SRV_Channel sú funkcie, ktoré môžu pomôcť pri vyčítaní PWM

Funkciu na posielanie do ESC bude treba implementovať do funkcie motors_output(), ktorá je volaná v ArduCopter.cpp

Zatiaľ neriešime read() iba write na serial!!

Funkcia ADB_Proto::tick() sa volá s frekvenciou 1 KHz. My chceme 400 - toto dosiahneme volaním funkcie 
AP_HAL::millis(), takto (akurát nie % 100, ale s vhodným číslom):
    
    if (AP_HAL::millis() % 100 == 0){
        hal.uartE->write(msg,42);
    }
    


    



    	
	
	



	
	
	

